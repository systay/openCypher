= CIP2015-05-13 - EXISTENTIAL SUBQUERIES
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Andr√©s Taylor <andres@neotechnology.com>


[abstract]
.Abstract
--
This CIP introduces EXISTS, a general function that can test for the existence of properties, simple patterns and full subqueries.
--

toc::[]

== Background

In a way, Cypher already has existential subqueries - pattern predicates allow checking for the existence of subgraphs.
This form is helpful, but not exhaustive in the types of subqueries that users want to be able to express.

== Proposal

To make this feature more powerful, add a new function named +EXISTS+ that would exist in two forms:

 * Property existence checking
 * Subquery existence checking

=== Syntax

----
expression = <current definition of expression>
           | property exists
           | subquery exists
           | simple subquery exists
            ;

property exists = "EXISTS", "(", expression ")"
                ;

subquery exists = "EXISTS", "{", read only clause, { read only clause }, "}" ;

simple subquery exists = "EXISTS", "{", simple match, "}" ;

simple match = pattern, { ",", pattern }, [ "WHERE", predicate ] ;

----
Note: the read-only clause above includes WITH but not RETURN.

=== Semantics

All forms of +EXIST(...)+ accomplish the same task - check if a particular pattern exists in the database.
They are expressions, and as such must be side-effect free; that is, the subqueries in +EXIST+ must not be updating queries.
Regarding nomenclature, all forms of +EXISTS+ are scalar expressions - they return a single boolean value, and this value is never +null+.

==== Property exists

In the property checking form, any expression is accepted as the input.
If the input expression returns a +null+ value, +EXISTS(...)+ returns false, and for all other values, it will return +true+.
This form of +EXISTS(...)+ is equivalent to checking for +null+ using +IS NOT NULL+; i.e. +EXISTS(expr)+ is equivalent to +expr IS NOT NULL+.

This form is there to make property existence checking idiomatic in Cypher - we do not want the user thinking of missing properties as checking for +null+ values.

==== Subquery exists
When checking for the existence of subqueries, variables and parameters from the outer query are available in the subquery.
Variables introduced in the subquery are not available on the outside.

For each matching subgraph evaluated with +EXISTS{...}+, the result value must be true if the subquery finds at least one matching row.
If no matches are found, false should be returned.

The subquery used in +EXISTS{...}+ has to follow the following rules:

 * It has to be a read-only query. Updating the graph as part of a predicate is not allowed.
 * It cannot end in a +RETURN+ clause, nor may it contain +UNION+
 * If +WITH+ ends the subquery, it should be able to change the cardinality of the subquery in an for +EXISTS(...)+ interesting way.
In other words, they should include +WHERE+ or +SKIP+, since they could turn a query that returns rows into one that does not.

==== Simple subquery exists
When the subquery can be described with a single +MATCH-WHERE+ clause, the +MATCH+ keyword can be omitted.
The difference between this form and a simple pattern predicate, which is already available is that this form allows for introducing new variables inside the +EXISTS(...)+ scope.

=== Examples
_Example 1A:_

Return all nodes that have a property named slogan.
[source, cypher]
----
MATCH (actor)
WHERE EXISTS(actor.slogan)
RETURN actor
----

_Example 1B:_
Return all nodes with both first name and second name:
[source, cypher]
----
MATCH (actor)
WHERE EXISTS(actor.firstName + actor.lastName)
RETURN actor
----

_Example 2A:_

Find all actors who have acted together with another actor with the same name.

[source, cypher]
----
MATCH (actor:Actor)
WHERE EXISTS {
	(other:Actor)-[:ACTED_IN]->(movie)<-[:ACTED_IN]-(actor)
	WHERE other.name = actor.name
}
RETURN actor
----

_Example 2B:_

Find all actors who have acted together with another actor with the same name.

[source, cypher]
----
MATCH (actor:Actor)
WHERE EXISTS {
	MATCH (other:Actor)-[:ACTED_IN]->(movie)<-[:ACTED_IN]-(actor)
	WHERE other.name = actor.name
}
RETURN actor
----

=== Interaction with existing features
This replaces the pre-existing +HAS(...)+ function.

== What others do

This is very similar to what SQL does with its EXISTS functionality.

This is also very similar in syntax to what SPARQL does with its EXISTS functionality; the rules regarding variables are identical, and the inner query also takes a subquery as input.

== Benefits to this proposal

The existing pattern predicate functionality is very useful, but does not cover all cases.
Pattern predicates do not allow for introducing variables, which makes some queries - such as the one below - difficult to express succinctly:

[source, cypher]
----
MATCH (person:Person)
WHERE EXISTS {
  (person)-[:HAS_DOG]->(dog:Dog)
  WHERE person.name = dog.name
}
RETURN person
----

This proposal also allows for powerful subqueries, for example using aggregation inside the EXISTS query.
E.g. find all teams that have at least two members who have worked on successful projects.

[source, cypher]
----
MATCH (team:Team)
WHERE EXISTS {
  MATCH (team)-[:HAS_MEMBER]->(member:Person)
  WHERE EXISTS {
	(member)-[:WORKED_ON]->(p:Project) WHERE p.successful
  }
  WITH team, count(*) AS numAPlayers
  WHERE numAPlayers > 2
}
RETURN team
----

== Caveats to this proposal

Subqueries are powerful constructs. As such they can be difficult to understand, and difficult for a query planner to get right.
